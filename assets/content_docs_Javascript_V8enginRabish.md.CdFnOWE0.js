import{_ as a,c as e,o as t,a8 as r,ap as i,aq as o,ar as s,as as n,at as c,au as h,av as l}from"./chunks/framework.DuxrSgz9.js";const V=JSON.parse('{"title":"V8引擎垃圾回收机制","description":"","frontmatter":{"title":"V8引擎垃圾回收机制","group":"JavaScript","layout":"post","date":"2021-01-02T05:54:36.000Z","tags":["JavaScript"],"sidebar":true,"summary":"V8引擎垃圾回收机制"},"headers":[],"relativePath":"content/docs/Javascript/V8enginRabish.md","filePath":"content/docs/Javascript/V8enginRabish.md"}'),p={name:"content/docs/Javascript/V8enginRabish.md"},d=r('<h1 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h1><p>追踪记录每个值被引用的次数，如果一个值的引用次数是0，则说明这个值不再用到了。则可以释放这个值的内存空间。</p><p>一个值被引用一次，计数就加1，释放就减1，变为0时，就可以释放这个块内存。</p><p>*IE8及之前的浏览器使用的规则</p><h1 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h1><p>现代浏览器使用普遍使用这个机制。</p><p>当变量进入环境时，标记为这个变量为“进入环境”，当变量离开环境时，标记这个变量为“离开环境”。</p><p>最后，垃圾回收器销毁掉被标记为“离开环境”的变量所占用的内存空间。</p><h2 id="执行环境" tabindex="-1">执行环境 <a class="header-anchor" href="#执行环境" aria-label="Permalink to &quot;执行环境&quot;">​</a></h2><img src="'+i+'"><h2 id="全局环境" tabindex="-1">全局环境 <a class="header-anchor" href="#全局环境" aria-label="Permalink to &quot;全局环境&quot;">​</a></h2><img src="'+o+'"><h2 id="局部环境" tabindex="-1">局部环境 <a class="header-anchor" href="#局部环境" aria-label="Permalink to &quot;局部环境&quot;">​</a></h2><img src="'+s+'"><h1 id="v8引擎回收策略" tabindex="-1">V8引擎回收策略 <a class="header-anchor" href="#v8引擎回收策略" aria-label="Permalink to &quot;V8引擎回收策略&quot;">​</a></h1><p>V8将内存分为两个生代，采用不同的算法进行垃圾回收。</p><h2 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h2><img src="'+n+'"><p>回收新生代对象，主要通过Scavenge算法进行垃圾回收,在Scavenge的具体 实现中,主要采用了Cheney算法。</p><p>Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二,每一部分空间称为 semispace。在这两个 semispace 空间中,只有一个处于使用中,另一个处于闲置状态。处于使用状态的空间称为 From 空间,处于闲置状态的空间称为 To 空间。当我们分配对象时,先是在 From 空间中进行分配。当开始进行垃圾回收时,会检查 From 空间中的存活对象,这些存活对象将被复制到 To 空间中, 然后反转From、To空间，释放To空间的内存。</p><h2 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h2><img src="'+c+'"><h3 id="标记清除-1" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除-1" aria-label="Permalink to &quot;标记清除&quot;">​</a></h3><img src="'+h+'"><p>标记清除会造成内存空间不连续的问题。</p><h3 id="标记合并" tabindex="-1">标记合并 <a class="header-anchor" href="#标记合并" aria-label="Permalink to &quot;标记合并&quot;">​</a></h3><img src="'+l+'"><h1 id="增量标记" tabindex="-1">增量标记 <a class="header-anchor" href="#增量标记" aria-label="Permalink to &quot;增量标记&quot;">​</a></h1><p>为了避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况,垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来,待执行完垃圾回收后再恢复执行应用逻辑,这种行为被称为“全停顿&quot;，长时间的&quot;全停顿&quot;垃圾回收会让用户感受到明显的卡顿，带来体验的影响。以1.5 GB的垃圾回收堆内存为例,V8做一次小的垃圾回收需要50毫秒以上,做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间,在 这样的时间花销下,应用的性能和响应能力都会直线下降。</p><p>为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改为增量标记(incremental marking),也就是拆分为许多小“步进”,每做完一“步进” 就让 JavaScript 应用逻辑执行一小会儿,垃圾回收与应用逻辑交替执行直到标记阶段完成</p>',30),m=[d];function _(u,b,q,f,g,v){return t(),e("div",null,m)}const k=a(p,[["render",_]]);export{V as __pageData,k as default};
